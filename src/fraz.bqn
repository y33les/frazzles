curl â† â€¢Import "../lib/bqn-curl/curl.bqn"
read â† â€¢Import "read.bqn"
err â† â€¢Import "err.bqn"
msg â† â€¢Import "msg.bqn"
str â† â€¢Import "str.bqn"

cmdSet â† âŸ¨"new","init","add","remove","search","help"âŸ© # Allowed commands
cmdHelpMap â† cmdSet â€¢HashMap âŸ¨msg.help.new,msg.help.init,msg.help.add,msg.help.remove,msg.help.search,msg.help.helpâŸ© # Allowed commands with their corresponding help messages
frazIndex â† "get.frazzl.es" # Default Frazzle index

# Process arguments: fraz <cmd> <args>
args â† â€¢args
{ 0=â‰ ğ•© ? â€¢Out msg.help.fraz â‹„ â€¢Exit 0 ; @ }args # Display help message if no arguments provided
cmd â† âŠ‘args
(âˆŠâŸœcmdSetâŒ¾<cmd) err._Assert_ ("Allowed commands are: "âˆ¾{ğ•¨âˆ¾", "âˆ¾ğ•©}Â´cmdSet) # Fail if cmd is unknown
args 1âŠ¸â†“â†©

configHeaders â† âŸ¨"name","description","author","version","type","licence","dependencies"âŸ©
InputConfig â† {
  â€¢Out "Frazzle name:"
  name â† read.LineNoBlank ğ•©
  â€¢Out "Description:"
  description â† read.LineNoBlank ğ•©
  â€¢Out "Author:"
  author â† read.LineNoBlank ğ•©
  â€¢Out "Version number:"
  version â† read.LineNoBlank ğ•©
  â€¢Out "Frazzle type ('app' or 'lib'):"
  type â† {lâ†read.LineNoBlank ğ•© â‹„ (lâ‰¡"app")âˆ¨(lâ‰¡"lib") ? l ; â€¢Out "Frazzle type must be either 'app' or 'lib'." â‹„ ğ•Š ğ•©} ğ•©
  â€¢Out "Licence:"
  licence â† read.LineNoBlank ğ•©
  dependencies â† âŸ¨âŸ©
  âŸ¨name,description,author,version,type,licence,dependenciesâŸ©
}
# Generate a config HashMap where ğ•© is a list of corresponding to the Frazzle name (string), description (string), author (string), version (string), type (string: "app" or "lib") licence (string) and dependencies (list of strings).
# TODO: Implement dependency versioning like in Python (e.g. "numpy==1.1.14")
# TODO: Type checking
GenConfig â‡ {
  nâ†â‰ configHeaders
  ("GenConfig requires a list of length "âˆ¾(â€¢Fmt n)âˆ¾".")!n=â‰ ğ•©
  configHeaders â€¢HashMap ğ•©
}
ReadConfig â‡ { ğ•© }
WriteConfig â‡ { ğ•¨ â€¢file.Bytes ğ•© } # TODO: input checking

New â‡ {
  (1=â‰ ğ•©) err._Assert_ msg.use.new
  dir â† â€¢wdpath â€¢file.At âŠ‘ğ•©
  (Â¬â€¢file.Exists dir) err._Assert_ ("Directory "âˆ¾dirâˆ¾" already exists.")
  â€¢file.CreateDir dir
  frazFile â† dir â€¢file.At ".frazzle"
  frazFile WriteConfig GenConfig InputConfig ""
  â€¢Out "New Frazzle created in "âˆ¾dirâˆ¾"."
}

Init â‡ {
  (0=â‰ ğ•©) err._Assert_ "fraz init does not accept arguments.  Did you mean 'fraz new <dir>'?"
  frazFile â† â€¢wdpath â€¢file.At ".frazzle"
  (Â¬â€¢file.Exists frazFile) err._Assert_ "This directory is already a Frazzle."
  WriteConfig frazFile
  â€¢Out "Frazzle initialised in "âˆ¾â€¢wdpath
}

Add â‡ {
  (0â‰ â‰ ğ•©) err._Assert_ msg.use.add
  {"-i"â‰¡âŠ‘ğ•© ? (2<â‰ ğ•©) err._Assert_ msg.use.add â‹„ frazIndex â†© 1âŠ‘ğ•© ; @}ğ•©
  â€¢Out frazIndex
}

Remove â‡ { â€¢ShowâŒ½Â¨ğ•© }

SearchFrazzle â† { # TODO: Make it able to search descriptions as well, once I've figured out how to store and provide them
  (0â‰ â‰ ğ•©) err._Assert_ msg.use.search
  offset â† 0 # Where the search term is (in case -i is used)
  {"-i"â‰¡âŠ‘ğ•© ? (3=â‰ ğ•©) err._Assert_ msg.use.search â‹„ frazIndex â†© 1âŠ‘ğ•© â‹„ offsetâ†©2 ; (1=â‰ ğ•©) err._Assert_ msg.use.search}ğ•©
  search â† offsetâŠ‘ğ•©
  response â† curl.Get "ftp://"âˆ¾frazIndex # TODO: add check to make sure no protocol:// header
  (226=response.code) err._Assert_ ("Failed to fetch Frazzle index with code "âˆ¾(â€¢Fmt response.code)âˆ¾".") # 226 is FTP OK
  files â† str.lf str.Split response.content
  files {âŠ‘âŒ½' ' str.Split ğ•©}Â¨â†©
  frazzles â† ".frz" str.SearchList files
  results â† search str.SearchList Â¯4â†“Â¨frazzles
}
GetDescription â† {
  # TODO: input checks
  response â† curl.Get âˆ¾Â´"dict://"âˆ¾ğ•¨âˆ¾"/d:"âˆ¾ğ•© # TODO: add check to make sure no protocol:// header
  response â†© str.lfâŠ¸str.CutÂ¨ str.cr str.Cut response.content
  (552â‰ str.ParseInt 3â†‘âŠ‘2âŠ‘response) err._Assert_ (âˆ¾Â´"There is no Frazzle named '"âˆ¾ğ•©âˆ¾"' at "âˆ¾ğ•¨âˆ¾".") # 552 is the DICT code for no entries found
  result â† âŠ‘4âŠ‘response
}
Search â‡ { â€¢OutÂ¨ frazIndexâŠ¸GetDescriptionÂ¨ SearchFrazzle ğ•© }

Help â‡ {
  (2>â‰ ğ•©) err._Assert_ msg.use.help
  { 0=â‰ ğ•© ? â€¢Out msg.help.fraz â‹„ â€¢Exit 0 ; @ }ğ•© # Display toplevel help message if no command provided
  (âˆŠâŸœcmdSetâŒ¾<âŠ‘ğ•©) err._Assert_ ("Allowed commands are: "âˆ¾{ğ•¨âˆ¾", "âˆ¾ğ•©}Â´cmdSet)
  â€¢Out cmdHelpMap.Get âŠ‘ğ•© 
}

cmdFnMap â† cmdSet â€¢HashMap âŸ¨new,init,add,remove,search,helpâŸ© # Allowed commands with their corresponding functions

# Run it!
args{ğ•ğ•¨}cmdFnMap.Get cmd

# 4